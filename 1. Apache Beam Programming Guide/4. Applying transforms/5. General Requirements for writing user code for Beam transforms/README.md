### General Requirements for writing user code for Beam transforms

 Beam transform 을 위한 사용자 코드를 작성할 때 분산 된 실행 특성을 유념해야합니다. 예를들어, 동시에 다른 많은 머신에서 당신의 function 의 복사본이 있고, 그 function 들은 다른 복사본들과 상태를 공유하지 않는 독립적인 형태입니다. Pipeline Runner 와 당신의 pipeline 을 위해 선택한 processing back-end 에 의존하여, 각각의 당신의 user code function 은 재시도하고, 여러번 실행됩니다. 이와같이, 당신은 코드에 상태에 의존적인 것들을 포함시키지 않도록 유의해야 합니다.

 일반적으로, user code 는 다음과 같은 요구사항을 만족해야 합니다.
 - 직렬화 가능
 - 스레드 호환 가능해야하며 Beam SDK는 스레드로부터 안전하지 않음에 유의.

그리고, 함수가 멱등성을 가지도록 만드는 것을 추천합니다.

> **Note** 이러한 요구 사항은 DoFn (ParDo 변환과 함께 사용되는 함수 오브젝트), CombineFn (Combine 변환과 함께 사용되는 함수 오브젝트) 및 WindowFn (Window 변환과 함께 사용되는 함수 오브젝트)의 하위 클래스에 적용됩니다.

#### Serializability (연속성)

transform 하기 위해 사용되는 함수들은 연속성이 있어야 합니다. 이는 함수 복사본을 직렬화하여 처리 클러스터의 원격 worker에게 전송해야하기 때문입니다. user code 를 위한 `DoFn`, `CombineFn`, `WindowFn`과 같은  베이스 클래스는, 이미 `Serializable`을 implement 합니다.

> **역자공부** Serializable 은 객체의 저장 또는 전송을 위해서 자바 코드를 다시 복원 가능한 byte stream 형태로 변환시켜 주는 것이다. object graph 를 통해서 복원할 수 있도록 하는 것이다.

당신이 알고 있어야 하는 직렬화와 관련된 다른 요인은 다음과 같습니다.
- 객체의 일시적인 필드는 자동으로 직렬화되지 않기 때문에 작업자 인스턴스로 전송되지 않습니다.
- 직렬화 전에 거대한 양의 데이터를 로딩하는 것을 피해야 합니다.
- 당신의 객체의 각각의 인스턴스는 데이터를 공유할 수 없습니다.
- 객체가 적용된 후에 객체를 변경하면 효과가 없습니다.
- 익명 inner 클래스 인스턴스를 사용하여 객체를 인라인으로 선언할 때는 주의하십시오. 정적이 아닌 컨텍스트에서 내부 클래스 인스턴스는 암시 적으로 둘러싸는 클래스 및 해당 클래스의 상태에 대한 포인터를 포함합니다. 그 땐 클로징 클래스도 직렬화 될 것이므로 함수 객체 자체에 적용되는 것과 동일한 고려 사항이 외부 클래스에도 적용됩니다.(설명좀요..)

#### Tread-compatibility

당신의 오브젝트는 쓰레드에 호환 가능해야 합니다. 당신의 객체의 각각의 인스턴스는 당신이 명시적으로 자시남ㄴ의 스레드를 만들지 않는 이상 단일 스레드에 의해 worker 인스턴스에 접근되어집니다. 그러나, **Beam SDK 는 스레드에 안전하지 않음** 에 유의하십시오. 만약 당신이 user code 에 당신만의 스레드를 만들었다면, 당신은 당신의 synchronization 을 제공해야 합니다. 당신의 객체의 static member는 worker instance에게 넘겨지지 않
고, 당신의 function 의 많은 인스턴스들이 다른 스레드로부터 접근되어짐에 유의하십시오.(...)

#### Idempotence

의도되지 않는 반복이 있을 수 있기 때문에 멱등성을 가지도록 당신의 함수를 작성해야 합니다. Beam 모델은 당신의 코드가 몇번 돌아갈지에 대한 보장을 제공하지 않습니다. 멱등성을 가지도록 당신의 함수를 작성하면, 당신의 transform 의 행동은 더욱 예측 가능하고 디버깅하기 쉬워집니다.
